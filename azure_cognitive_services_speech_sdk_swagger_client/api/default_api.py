# coding: utf-8

"""
    Speech Services API v3.1

    Speech Services API v3.1.  # noqa: E501

    OpenAPI spec version: v3.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from azure_cognitive_services_speech_sdk_swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def datasets_commit_blocks(self, id, **kwargs):  # noqa: E501
        """Commit Block List  # noqa: E501

        Commit block list to complete the upload of the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_commit_blocks(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param CommitBlocksEntryArray commit_blocks_entry_array: The list of blocks that compile the dataset.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_commit_blocks_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.datasets_commit_blocks_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def datasets_commit_blocks_with_http_info(self, id, **kwargs):  # noqa: E501
        """Commit Block List  # noqa: E501

        Commit block list to complete the upload of the dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_commit_blocks_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param CommitBlocksEntryArray commit_blocks_entry_array: The list of blocks that compile the dataset.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "commit_blocks_entry_array"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_commit_blocks" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_commit_blocks`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "commit_blocks_entry_array" in params:
            body_params = params["commit_blocks_entry_array"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}/blocks:commit",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_create(self, **kwargs):  # noqa: E501
        """Create Dataset  # noqa: E501

        Uploads and creates a new dataset by getting the data from a specified URL or starts waiting for data blocks to be uploaded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dataset dataset: Definition for the new dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.datasets_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def datasets_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Dataset  # noqa: E501

        Uploads and creates a new dataset by getting the data from a specified URL or starts waiting for data blocks to be uploaded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dataset dataset: Definition for the new dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["dataset"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "dataset" in params:
            body_params = params["dataset"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Dataset",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_delete(self, id, **kwargs):  # noqa: E501
        """Delete Dataset  # noqa: E501

        Deletes the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.datasets_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def datasets_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Dataset  # noqa: E501

        Deletes the specified dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_get(self, id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Gets the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.datasets_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def datasets_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Dataset  # noqa: E501

        Gets the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Dataset",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_get_blocks(self, id, **kwargs):  # noqa: E501
        """Get Uploaded Blocks  # noqa: E501

        Gets the list of uploaded blocks for this dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get_blocks(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: UploadedBlocks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_get_blocks_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.datasets_get_blocks_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def datasets_get_blocks_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Uploaded Blocks  # noqa: E501

        Gets the list of uploaded blocks for this dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get_blocks_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :return: UploadedBlocks
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_get_blocks" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_get_blocks`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}/blocks",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="UploadedBlocks",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_get_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Dataset File  # noqa: E501

        Gets one specific file (identified with fileId) from a dataset (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.datasets_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
            return data

    def datasets_get_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Dataset File  # noqa: E501

        Gets one specific file (identified with fileId) from a dataset (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_get_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "file_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_get_file" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_get_file`"
            )  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and (
            "file_id" not in params or params["file_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `file_id` when calling `datasets_get_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "file_id" in params:
            path_params["fileId"] = params["file_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}/files/{fileId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_list(self, **kwargs):  # noqa: E501
        """Get Datasets  # noqa: E501

        Gets a list of datasets for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available datasets.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale, kind.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z and displayName eq 'My dataset'```</li></ul>
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.datasets_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def datasets_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Datasets  # noqa: E501

        Gets a list of datasets for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available datasets.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale, kind.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z and displayName eq 'My dataset'```</li></ul>
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedDatasets",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_list_files(self, id, **kwargs):  # noqa: E501
        """Get Dataset Files  # noqa: E501

        Gets the files of the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_list_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.datasets_list_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def datasets_list_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Dataset Files  # noqa: E501

        Gets the files of the dataset identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "sas_validity_in_seconds",
            "skip",
            "top",
            "filter",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_list_files" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_list_files`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}/files",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Datasets  # noqa: E501

        Gets a list of supported locales for datasets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DatasetLocales
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.datasets_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def datasets_list_supported_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Datasets  # noqa: E501

        Gets a list of supported locales for datasets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DatasetLocales
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="DatasetLocales",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_update(self, id, **kwargs):  # noqa: E501
        """Update Dataset  # noqa: E501

        Updates the mutable details of the dataset identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param DatasetUpdate dataset_update: The updated values for the dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.datasets_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def datasets_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Dataset  # noqa: E501

        Updates the mutable details of the dataset identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param DatasetUpdate dataset_update: The updated values for the dataset.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "dataset_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "dataset_update" in params:
            body_params = params["dataset_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Dataset",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_upload(self, display_name, locale, kind, **kwargs):  # noqa: E501
        """Upload Dataset From Form  # noqa: E501

        Uploads data and creates a new dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_upload(display_name, locale, kind, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str display_name: The name of this dataset (required). (required)
        :param str locale: The locale of this dataset (required). (required)
        :param str kind: The kind of the dataset (required). Possible values are \"Language\", \"Acoustic\", \"Pronunciation\", \"AudioFiles\", \"LanguageMarkdown\". (required)
        :param str project: The optional string representation of the url of a project. If set, the dataset will be associated with that project.
        :param str description: Optional description of this dataset.
        :param str custom_properties: The optional custom properties of this entity. The maximum allowed key length is 64 characters, the maximum allowed value length is 256 characters and the count of allowed entries is 10.
        :param file data: For acoustic datasets, a zip file containing the audio data and a text file containing the transcriptions for the audio data. For language datasets, a text file containing the language or pronunciation data. Required in both cases.
        :param str email: An optional string containing the email address to send email notifications to in case the operation completes. The value will be removed after successfully sending the email.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_upload_with_http_info(
                display_name, locale, kind, **kwargs
            )  # noqa: E501
        else:
            (data) = self.datasets_upload_with_http_info(
                display_name, locale, kind, **kwargs
            )  # noqa: E501
            return data

    def datasets_upload_with_http_info(
        self, display_name, locale, kind, **kwargs
    ):  # noqa: E501
        """Upload Dataset From Form  # noqa: E501

        Uploads data and creates a new dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_upload_with_http_info(display_name, locale, kind, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str display_name: The name of this dataset (required). (required)
        :param str locale: The locale of this dataset (required). (required)
        :param str kind: The kind of the dataset (required). Possible values are \"Language\", \"Acoustic\", \"Pronunciation\", \"AudioFiles\", \"LanguageMarkdown\". (required)
        :param str project: The optional string representation of the url of a project. If set, the dataset will be associated with that project.
        :param str description: Optional description of this dataset.
        :param str custom_properties: The optional custom properties of this entity. The maximum allowed key length is 64 characters, the maximum allowed value length is 256 characters and the count of allowed entries is 10.
        :param file data: For acoustic datasets, a zip file containing the audio data and a text file containing the transcriptions for the audio data. For language datasets, a text file containing the language or pronunciation data. Required in both cases.
        :param str email: An optional string containing the email address to send email notifications to in case the operation completes. The value will be removed after successfully sending the email.
        :return: Dataset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "display_name",
            "locale",
            "kind",
            "project",
            "description",
            "custom_properties",
            "data",
            "email",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_upload" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'display_name' is set
        if self.api_client.client_side_validation and (
            "display_name" not in params or params["display_name"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `display_name` when calling `datasets_upload`"
            )  # noqa: E501
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and (
            "locale" not in params or params["locale"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `locale` when calling `datasets_upload`"
            )  # noqa: E501
        # verify the required parameter 'kind' is set
        if self.api_client.client_side_validation and (
            "kind" not in params or params["kind"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `kind` when calling `datasets_upload`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "project" in params:
            form_params.append(("project", params["project"]))  # noqa: E501
        if "display_name" in params:
            form_params.append(("displayName", params["display_name"]))  # noqa: E501
        if "description" in params:
            form_params.append(("description", params["description"]))  # noqa: E501
        if "locale" in params:
            form_params.append(("locale", params["locale"]))  # noqa: E501
        if "kind" in params:
            form_params.append(("kind", params["kind"]))  # noqa: E501
        if "custom_properties" in params:
            form_params.append(
                ("customProperties", params["custom_properties"])
            )  # noqa: E501
        if "data" in params:
            local_var_files["data"] = params["data"]  # noqa: E501
        if "email" in params:
            form_params.append(("email", params["email"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["multipart/form-data"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/upload",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Dataset",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def datasets_upload_block(self, id, blockid, **kwargs):  # noqa: E501
        """Upload Data Block  # noqa: E501

        Upload a block of data for the dataset. The maximum size of the block is 8MiB.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_upload_block(id, blockid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str blockid: A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block. Note that the Base64 string must be URL-encoded. (required)
        :param Body body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.datasets_upload_block_with_http_info(
                id, blockid, **kwargs
            )  # noqa: E501
        else:
            (data) = self.datasets_upload_block_with_http_info(
                id, blockid, **kwargs
            )  # noqa: E501
            return data

    def datasets_upload_block_with_http_info(self, id, blockid, **kwargs):  # noqa: E501
        """Upload Data Block  # noqa: E501

        Upload a block of data for the dataset. The maximum size of the block is 8MiB.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.datasets_upload_block_with_http_info(id, blockid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the dataset. (required)
        :param str blockid: A valid Base64 string value that identifies the block. Prior to encoding, the string must be less than or equal to 64 bytes in size. For a given blob, the length of the value specified for the blockid parameter must be the same size for each block. Note that the Base64 string must be URL-encoded. (required)
        :param Body body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "blockid", "body"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_upload_block" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `datasets_upload_block`"
            )  # noqa: E501
        # verify the required parameter 'blockid' is set
        if self.api_client.client_side_validation and (
            "blockid" not in params or params["blockid"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `blockid` when calling `datasets_upload_block`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "blockid" in params:
            query_params.append(("blockid", params["blockid"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "body" in params:
            body_params = params["body"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/octet-stream"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/datasets/{id}/blocks",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_create(self, **kwargs):  # noqa: E501
        """Create Endpoint  # noqa: E501

        Creates a new endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Endpoint endpoint: The details of the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def endpoints_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Endpoint  # noqa: E501

        Creates a new endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Endpoint endpoint: The details of the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["endpoint"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "endpoint" in params:
            body_params = params["endpoint"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Endpoint",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_delete(self, id, **kwargs):  # noqa: E501
        """Delete Endpoint  # noqa: E501

        Deletes the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def endpoints_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Endpoint  # noqa: E501

        Deletes the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_delete_base_model_log(self, locale, log_id, **kwargs):  # noqa: E501
        """Delete Base Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_base_model_log(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_delete_base_model_log_with_http_info(
                locale, log_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_delete_base_model_log_with_http_info(
                locale, log_id, **kwargs
            )  # noqa: E501
            return data

    def endpoints_delete_base_model_log_with_http_info(
        self, locale, log_id, **kwargs
    ):  # noqa: E501
        """Delete Base Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_base_model_log_with_http_info(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["locale", "log_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_delete_base_model_log" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and (
            "locale" not in params or params["locale"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `locale` when calling `endpoints_delete_base_model_log`"
            )  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and (
            "log_id" not in params or params["log_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `log_id` when calling `endpoints_delete_base_model_log`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "locale" in params:
            path_params["locale"] = params["locale"]  # noqa: E501
        if "log_id" in params:
            path_params["logId"] = params["log_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/base/{locale}/files/logs/{logId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_delete_base_model_logs(self, locale, **kwargs):  # noqa: E501
        """Delete All Base Model Endpoint Logs  # noqa: E501

        Deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_base_model_logs(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". For instance, \"2023-03-15\" results in deleting all logs on March 15th, 2023 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_delete_base_model_logs_with_http_info(
                locale, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_delete_base_model_logs_with_http_info(
                locale, **kwargs
            )  # noqa: E501
            return data

    def endpoints_delete_base_model_logs_with_http_info(
        self, locale, **kwargs
    ):  # noqa: E501
        """Delete All Base Model Endpoint Logs  # noqa: E501

        Deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_base_model_logs_with_http_info(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". For instance, \"2023-03-15\" results in deleting all logs on March 15th, 2023 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["locale", "end_date"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_delete_base_model_logs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and (
            "locale" not in params or params["locale"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `locale` when calling `endpoints_delete_base_model_logs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "locale" in params:
            path_params["locale"] = params["locale"]  # noqa: E501

        query_params = []
        if "end_date" in params:
            query_params.append(("endDate", params["end_date"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/base/{locale}/files/logs",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_delete_log(self, id, log_id, **kwargs):  # noqa: E501
        """Delete Custom Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_log(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_delete_log_with_http_info(
                id, log_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_delete_log_with_http_info(
                id, log_id, **kwargs
            )  # noqa: E501
            return data

    def endpoints_delete_log_with_http_info(self, id, log_id, **kwargs):  # noqa: E501
        """Delete Custom Model Endpoint Log  # noqa: E501

        Deletes one audio or transcription log that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_log_with_http_info(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "log_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_delete_log" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_delete_log`"
            )  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and (
            "log_id" not in params or params["log_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `log_id` when calling `endpoints_delete_log`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "log_id" in params:
            path_params["logId"] = params["log_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}/files/logs/{logId}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_delete_logs(self, id, **kwargs):  # noqa: E501
        """Delete All Custom Model Endpoint Logs  # noqa: E501

        The deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_logs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". For instance, \"2023-03-15\" results in deleting all logs on March 15th, 2023 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_delete_logs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_delete_logs_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def endpoints_delete_logs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete All Custom Model Endpoint Logs  # noqa: E501

        The deletion process is done asynchronously and can take up to one day depending on the amount of log files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_delete_logs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str end_date: The end date of the audio logs deletion (specific day, UTC).              Expected format: \"yyyy-mm-dd\". For instance, \"2023-03-15\" results in deleting all logs on March 15th, 2023 and before.              Deletes all existing logs when date is not specified.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "end_date"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_delete_logs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_delete_logs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "end_date" in params:
            query_params.append(("endDate", params["end_date"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}/files/logs",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_get(self, id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Gets the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def endpoints_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Endpoint  # noqa: E501

        Gets the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Endpoint",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_get_base_model_log(self, locale, log_id, **kwargs):  # noqa: E501
        """Get Base Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for the default base model in a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_base_model_log(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_get_base_model_log_with_http_info(
                locale, log_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_get_base_model_log_with_http_info(
                locale, log_id, **kwargs
            )  # noqa: E501
            return data

    def endpoints_get_base_model_log_with_http_info(
        self, locale, log_id, **kwargs
    ):  # noqa: E501
        """Get Base Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for the default base model in a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_base_model_log_with_http_info(locale, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["locale", "log_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_get_base_model_log" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and (
            "locale" not in params or params["locale"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `locale` when calling `endpoints_get_base_model_log`"
            )  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and (
            "log_id" not in params or params["log_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `log_id` when calling `endpoints_get_base_model_log`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "locale" in params:
            path_params["locale"] = params["locale"]  # noqa: E501
        if "log_id" in params:
            path_params["logId"] = params["log_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/base/{locale}/files/logs/{logId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_get_log(self, id, log_id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_log(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_get_log_with_http_info(
                id, log_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_get_log_with_http_info(
                id, log_id, **kwargs
            )  # noqa: E501
            return data

    def endpoints_get_log_with_http_info(self, id, log_id, **kwargs):  # noqa: E501
        """Get Custom Model Endpoint Log  # noqa: E501

        Gets a specific audio or transcription log for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_get_log_with_http_info(id, log_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param str log_id: The identifier of the log. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "log_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_get_log" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_get_log`"
            )  # noqa: E501
        # verify the required parameter 'log_id' is set
        if self.api_client.client_side_validation and (
            "log_id" not in params or params["log_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `log_id` when calling `endpoints_get_log`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "log_id" in params:
            path_params["logId"] = params["log_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}/files/logs/{logId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_list(self, **kwargs):  # noqa: E501
        """Get Endpoints  # noqa: E501

        Gets the list of endpoints for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available endpoints.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=locale eq 'en-US'```</li></ul>
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def endpoints_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Endpoints  # noqa: E501

        Gets the list of endpoints for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available endpoints.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=locale eq 'en-US'```</li></ul>
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedEndpoints",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_list_base_model_logs(self, locale, **kwargs):  # noqa: E501
        """Get Base Model Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_base_model_logs(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_list_base_model_logs_with_http_info(
                locale, **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_list_base_model_logs_with_http_info(
                locale, **kwargs
            )  # noqa: E501
            return data

    def endpoints_list_base_model_logs_with_http_info(
        self, locale, **kwargs
    ):  # noqa: E501
        """Get Base Model Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored when using the default base model of a given language.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_base_model_logs_with_http_info(locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The language used to select the default base model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "locale",
            "sas_validity_in_seconds",
            "skip_token",
            "top",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_list_base_model_logs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'locale' is set
        if self.api_client.client_side_validation and (
            "locale" not in params or params["locale"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `locale` when calling `endpoints_list_base_model_logs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "locale" in params:
            path_params["locale"] = params["locale"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip_token" in params:
            query_params.append(("skipToken", params["skip_token"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/base/{locale}/files/logs",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_list_logs(self, id, **kwargs):  # noqa: E501
        """Get Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_logs(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_list_logs_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_list_logs_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def endpoints_list_logs_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Endpoint Logs  # noqa: E501

        Gets the list of audio and transcription logs that have been stored for a given endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_logs_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param str skip_token: Token to skip logs that were already retrieved in previous requests. Pagination starts from beginning when not defined.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "sas_validity_in_seconds",
            "skip_token",
            "top",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_list_logs" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_list_logs`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip_token" in params:
            query_params.append(("skipToken", params["skip_token"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}/files/logs",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Endpoints  # noqa: E501

        Gets a list of supported locales for endpoint creations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EndpointsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.endpoints_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def endpoints_list_supported_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Endpoints  # noqa: E501

        Gets a list of supported locales for endpoint creations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EndpointsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="EndpointsLocalesGet200ApplicationJsonResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def endpoints_update(self, id, **kwargs):  # noqa: E501
        """Update Endpoint  # noqa: E501

        Updates the metadata of the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param EndpointUpdate endpoint_update: The updated values for the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.endpoints_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.endpoints_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def endpoints_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Endpoint  # noqa: E501

        Updates the metadata of the endpoint identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.endpoints_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the endpoint. (required)
        :param EndpointUpdate endpoint_update: The updated values for the endpoint.
        :return: Endpoint
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "endpoint_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method endpoints_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `endpoints_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "endpoint_update" in params:
            body_params = params["endpoint_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/endpoints/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Endpoint",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_create(self, **kwargs):  # noqa: E501
        """Create Evaluation  # noqa: E501

        Creates a new evaluation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Evaluation evaluation: The details of the new evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.evaluations_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def evaluations_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Evaluation  # noqa: E501

        Creates a new evaluation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Evaluation evaluation: The details of the new evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["evaluation"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "evaluation" in params:
            body_params = params["evaluation"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Evaluation",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_delete(self, id, **kwargs):  # noqa: E501
        """Delete Evaluation  # noqa: E501

        Deletes the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.evaluations_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def evaluations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Evaluation  # noqa: E501

        Deletes the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `evaluations_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_get(self, id, **kwargs):  # noqa: E501
        """Get Evaluation  # noqa: E501

        Gets the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.evaluations_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def evaluations_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluation  # noqa: E501

        Gets the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `evaluations_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Evaluation",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_get_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Evaluation File  # noqa: E501

        Gets one specific file (identified with fileId) from an evaluation (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_get_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.evaluations_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
            return data

    def evaluations_get_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Evaluation File  # noqa: E501

        Gets one specific file (identified with fileId) from an evaluation (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_get_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "file_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_get_file" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `evaluations_get_file`"
            )  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and (
            "file_id" not in params or params["file_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `file_id` when calling `evaluations_get_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "file_id" in params:
            path_params["fileId"] = params["file_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/{id}/files/{fileId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_list(self, **kwargs):  # noqa: E501
        """Get Evaluations  # noqa: E501

        Gets the list of evaluations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available evaluations.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My evaluation'```</li></ul>
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.evaluations_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def evaluations_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Evaluations  # noqa: E501

        Gets the list of evaluations for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available evaluations.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My evaluation'```</li></ul>
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedEvaluations",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_list_files(self, id, **kwargs):  # noqa: E501
        """Get Evaluation Files  # noqa: E501

        Gets the files of the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_list_files_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.evaluations_list_files_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def evaluations_list_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluation Files  # noqa: E501

        Gets the files of the evaluation identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "sas_validity_in_seconds",
            "skip",
            "top",
            "filter",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_list_files" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `evaluations_list_files`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/{id}/files",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Evaluations  # noqa: E501

        Gets a list of supported locales for evaluations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EvaluationsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.evaluations_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def evaluations_list_supported_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Evaluations  # noqa: E501

        Gets a list of supported locales for evaluations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EvaluationsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="EvaluationsLocalesGet200ApplicationJsonResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def evaluations_update(self, id, **kwargs):  # noqa: E501
        """Update Evaluation  # noqa: E501

        Updates the mutable details of the evaluation identified by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param EvaluationUpdate evaluation_update: The object containing the updated fields of the evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.evaluations_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.evaluations_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def evaluations_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Evaluation  # noqa: E501

        Updates the mutable details of the evaluation identified by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.evaluations_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the evaluation. (required)
        :param EvaluationUpdate evaluation_update: The object containing the updated fields of the evaluation.
        :return: Evaluation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "evaluation_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method evaluations_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `evaluations_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "evaluation_update" in params:
            body_params = params["evaluation_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/evaluations/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Evaluation",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def health_status_get(self, **kwargs):  # noqa: E501
        """Get Health Status  # noqa: E501

        Returns the overall health of the service and optionally of the different subcomponents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_status_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceHealth
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.health_status_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.health_status_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def health_status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Health Status  # noqa: E501

        Returns the overall health of the service and optionally of the different subcomponents.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ServiceHealth
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_status_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/healthstatus",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ServiceHealth",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_copy_to(self, id, **kwargs):  # noqa: E501
        """Copy Model  # noqa: E501

        This method can be used to copy a model from one location to another. If the target subscription  key belongs to a subscription created for another location, the model will be copied to that location.  Only adapted models are allowed to copy to another subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_copy_to(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model that will be copied. (required)
        :param ModelCopy model_copy: The body contains the subscription key of the target subscription.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_copy_to_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_copy_to_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def models_copy_to_with_http_info(self, id, **kwargs):  # noqa: E501
        """Copy Model  # noqa: E501

        This method can be used to copy a model from one location to another. If the target subscription  key belongs to a subscription created for another location, the model will be copied to that location.  Only adapted models are allowed to copy to another subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_copy_to_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model that will be copied. (required)
        :param ModelCopy model_copy: The body contains the subscription key of the target subscription.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "model_copy"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_copy_to" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_copy_to`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "model_copy" in params:
            body_params = params["model_copy"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}:copyto",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomModel",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_create(self, **kwargs):  # noqa: E501
        """Create Model  # noqa: E501

        Creates a new model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CustomModel custom_model: The details of the new model.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.models_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def models_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Model  # noqa: E501

        Creates a new model.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CustomModel custom_model: The details of the new model.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["custom_model"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "custom_model" in params:
            body_params = params["custom_model"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomModel",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_delete(self, id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def models_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Model  # noqa: E501

        Deletes the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_get_base_model(self, id, **kwargs):  # noqa: E501
        """Get Base Model  # noqa: E501

        Gets the base model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_base_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the base model. (required)
        :return: BaseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_get_base_model_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_get_base_model_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def models_get_base_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Base Model  # noqa: E501

        Gets the base model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_base_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the base model. (required)
        :return: BaseModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_get_base_model" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_get_base_model`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/base/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="BaseModel",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_get_base_model_manifest(self, id, **kwargs):  # noqa: E501
        """Get Base Model Manifest  # noqa: E501

        Returns an manifest for this base model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_base_model_manifest(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_get_base_model_manifest_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.models_get_base_model_manifest_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def models_get_base_model_manifest_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Base Model Manifest  # noqa: E501

        Returns an manifest for this base model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_base_model_manifest_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_get_base_model_manifest" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_get_base_model_manifest`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/base/{id}/manifest",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ModelManifest",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_get_custom_model(self, id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Gets the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_custom_model(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_get_custom_model_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.models_get_custom_model_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def models_get_custom_model_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Model  # noqa: E501

        Gets the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_custom_model_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_get_custom_model" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_get_custom_model`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomModel",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_get_custom_model_manifest(self, id, **kwargs):  # noqa: E501
        """Get Model Manifest  # noqa: E501

        Returns an manifest for this model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_custom_model_manifest(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_get_custom_model_manifest_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.models_get_custom_model_manifest_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def models_get_custom_model_manifest_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Get Model Manifest  # noqa: E501

        Returns an manifest for this model which can be used in an on-premise container.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_custom_model_manifest_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The ID of the model to generate a manifest for. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: ModelManifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_get_custom_model_manifest" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_get_custom_model_manifest`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}/manifest",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ModelManifest",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_get_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Model File  # noqa: E501

        Gets one specific file (identified with fileId) from a model (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.models_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
            return data

    def models_get_file_with_http_info(self, id, file_id, **kwargs):  # noqa: E501
        """Get Model File  # noqa: E501

        Gets one specific file (identified with fileId) from a model (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_get_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "file_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_get_file" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_get_file`"
            )  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and (
            "file_id" not in params or params["file_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `file_id` when calling `models_get_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "file_id" in params:
            path_params["fileId"] = params["file_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}/files/{fileId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_list_base_models(self, **kwargs):  # noqa: E501
        """Get Base Models  # noqa: E501

        Gets the list of base models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_base_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available base models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedBaseModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_list_base_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.models_list_base_models_with_http_info(**kwargs)  # noqa: E501
            return data

    def models_list_base_models_with_http_info(self, **kwargs):  # noqa: E501
        """Get Base Models  # noqa: E501

        Gets the list of base models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_base_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available base models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedBaseModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_list_base_models" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/base",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedBaseModels",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_list_custom_models(self, **kwargs):  # noqa: E501
        """Get Models  # noqa: E501

        Gets the list of custom models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_custom_models(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedCustomModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_list_custom_models_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.models_list_custom_models_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def models_list_custom_models_with_http_info(self, **kwargs):  # noqa: E501
        """Get Models  # noqa: E501

        Gets the list of custom models for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_custom_models_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedCustomModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_list_custom_models" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedCustomModels",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_list_files(self, id, **kwargs):  # noqa: E501
        """Get Model Files  # noqa: E501

        Gets the files of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_list_files_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_list_files_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def models_list_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Model Files  # noqa: E501

        Gets the files of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav' and kind eq 'Audio'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "sas_validity_in_seconds",
            "skip",
            "top",
            "filter",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_list_files" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_list_files`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}/files",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Models  # noqa: E501

        Gets a list of supported locales for model adaptation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ModelsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.models_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def models_list_supported_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Models  # noqa: E501

        Gets a list of supported locales for model adaptation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ModelsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ModelsLocalesGet200ApplicationJsonResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def models_update(self, id, **kwargs):  # noqa: E501
        """Update Model  # noqa: E501

        Updates the metadata of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param ModelUpdate model_update: The updated values for the model.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.models_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.models_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def models_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Model  # noqa: E501

        Updates the metadata of the model identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the model. (required)
        :param ModelUpdate model_update: The updated values for the model.
        :return: CustomModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "model_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `models_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "model_update" in params:
            body_params = params["model_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/models/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="CustomModel",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_create(self, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Creates a new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Project project: The details of the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.projects_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def projects_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Project  # noqa: E501

        Creates a new project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Project project: The details of the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["project"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "project" in params:
            body_params = params["project"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Project",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_delete(self, id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Deletes the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def projects_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Project  # noqa: E501

        Deletes the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_get(self, id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Gets the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def projects_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Project  # noqa: E501

        Gets the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Project",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list(self, **kwargs):  # noqa: E501
        """Get Projects  # noqa: E501

        Gets the list of projects for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available projects.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, locale.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My test'```</li></ul>
        :return: PaginatedProjects
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.projects_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def projects_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Projects  # noqa: E501

        Gets the list of projects for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available projects.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, locale.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My test'```</li></ul>
        :return: PaginatedProjects
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedProjects",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_datasets(self, id, **kwargs):  # noqa: E501
        """Get Datasets for Project  # noqa: E501

        Gets the list of datasets for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_datasets(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available datasets.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale, kind.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_datasets_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.projects_list_datasets_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def projects_list_datasets_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Datasets for Project  # noqa: E501

        Gets the list of datasets for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_datasets_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available datasets.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale, kind.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedDatasets
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_datasets" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_list_datasets`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}/datasets",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedDatasets",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_endpoints(self, id, **kwargs):  # noqa: E501
        """Get Endpoints for Project  # noqa: E501

        Gets the list of endpoints for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_endpoints(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available endpoints.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=locale eq 'en-US'```</li></ul>
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_endpoints_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.projects_list_endpoints_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def projects_list_endpoints_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Endpoints for Project  # noqa: E501

        Gets the list of endpoints for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_endpoints_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available endpoints.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=locale eq 'en-US'```</li></ul>
        :return: PaginatedEndpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_endpoints" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_list_endpoints`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}/endpoints",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedEndpoints",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_evaluations(self, id, **kwargs):  # noqa: E501
        """Get Evaluations for Project  # noqa: E501

        Gets the list of evaluations for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_evaluations(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available evaluations.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My evaluation'```</li></ul>
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_evaluations_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.projects_list_evaluations_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def projects_list_evaluations_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Evaluations for Project  # noqa: E501

        Gets the list of evaluations for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_evaluations_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available evaluations.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'My evaluation'```</li></ul>
        :return: PaginatedEvaluations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_evaluations" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_list_evaluations`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}/evaluations",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedEvaluations",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_models(self, id, **kwargs):  # noqa: E501
        """Get Models for Project  # noqa: E501

        Gets the list of models for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_models(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedCustomModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_models_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_list_models_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def projects_list_models_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Models for Project  # noqa: E501

        Gets the list of models for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_models_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available models.              <ul><li><b>Supported properties: </b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=status eq 'NotStarted' or status eq 'Running'```</li></ul>
        :return: PaginatedCustomModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_models" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_list_models`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}/models",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedCustomModels",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Projects  # noqa: E501

        Gets the list of supported locales.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ProjectsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.projects_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def projects_list_supported_locales_with_http_info(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Projects  # noqa: E501

        Gets the list of supported locales.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ProjectsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ProjectsLocalesGet200ApplicationJsonResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_list_transcriptions(self, id, **kwargs):  # noqa: E501
        """Get Transcriptions for Project  # noqa: E501

        Gets the list of transcriptions for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_transcriptions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available transcriptions.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_list_transcriptions_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.projects_list_transcriptions_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def projects_list_transcriptions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcriptions for Project  # noqa: E501

        Gets the list of transcriptions for specified project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_list_transcriptions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available transcriptions.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_list_transcriptions" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_list_transcriptions`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}/transcriptions",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedTranscriptions",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def projects_update(self, id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Updates the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param ProjectUpdate project_update: The updated values for the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.projects_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def projects_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Project  # noqa: E501

        Updates the project identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the project. (required)
        :param ProjectUpdate project_update: The updated values for the project.
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "project_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `projects_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "project_update" in params:
            body_params = params["project_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/projects/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Project",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_create(self, **kwargs):  # noqa: E501
        """Create Transcription  # noqa: E501

        Creates a new transcription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Transcription transcription: The details of the new transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.transcriptions_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def transcriptions_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Transcription  # noqa: E501

        Creates a new transcription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Transcription transcription: The details of the new transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["transcription"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "transcription" in params:
            body_params = params["transcription"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Transcription",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_delete(self, id, **kwargs):  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified transcription task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.transcriptions_delete_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def transcriptions_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Transcription  # noqa: E501

        Deletes the specified transcription task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `transcriptions_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_get(self, id, **kwargs):  # noqa: E501
        """Get Transcription  # noqa: E501

        Gets the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.transcriptions_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def transcriptions_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcription  # noqa: E501

        Gets the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `transcriptions_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Transcription",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_get_file(self, id, file_id, **kwargs):  # noqa: E501
        """Get Transcription File  # noqa: E501

        Gets one specific file (identified with fileId) from a transcription (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_get_file(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.transcriptions_get_file_with_http_info(
                id, file_id, **kwargs
            )  # noqa: E501
            return data

    def transcriptions_get_file_with_http_info(
        self, id, file_id, **kwargs
    ):  # noqa: E501
        """Get Transcription File  # noqa: E501

        Gets one specific file (identified with fileId) from a transcription (identified with id).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_get_file_with_http_info(id, file_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param str file_id: Format - uuid. The identifier of the file. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :return: File
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "file_id", "sas_validity_in_seconds"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_get_file" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `transcriptions_get_file`"
            )  # noqa: E501
        # verify the required parameter 'file_id' is set
        if self.api_client.client_side_validation and (
            "file_id" not in params or params["file_id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `file_id` when calling `transcriptions_get_file`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "file_id" in params:
            path_params["fileId"] = params["file_id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/{id}/files/{fileId}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="File",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_list(self, **kwargs):  # noqa: E501
        """Get Transcriptions  # noqa: E501

        Gets a list of transcriptions for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available transcriptions.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.transcriptions_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def transcriptions_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Transcriptions  # noqa: E501

        Gets a list of transcriptions for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available transcriptions.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status, locale.                </li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=createdDateTime gt 2022-02-01T11:00:00Z```</li></ul>
        :return: PaginatedTranscriptions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedTranscriptions",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_list_files(self, id, **kwargs):  # noqa: E501
        """Get Transcription Files  # noqa: E501

        Gets the files of the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list_files(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav.json' and kind eq 'Transcription'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_list_files_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.transcriptions_list_files_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def transcriptions_list_files_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Transcription Files  # noqa: E501

        Gets the files of the transcription identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list_files_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param int sas_validity_in_seconds: Format - int32. The duration in seconds that an SAS url should be valid. The default duration is 12 hours.              When using BYOS (https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/speech-encryption-of-data-at-rest#bring-your-own-storage-byos-for-customization-and-logging): A value of 0 means that a plain blob URI without SAS token will be generated.
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available files.              <ul><li><b>Supported properties:</b> name, createdDateTime, kind.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=name eq 'myaudio.wav.json' and kind eq 'Transcription'```</li></ul>
        :return: PaginatedFiles
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "sas_validity_in_seconds",
            "skip",
            "top",
            "filter",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_list_files" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `transcriptions_list_files`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "sas_validity_in_seconds" in params:
            query_params.append(
                ("sasValidityInSeconds", params["sas_validity_in_seconds"])
            )  # noqa: E501
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/{id}/files",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedFiles",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_list_supported_locales(self, **kwargs):  # noqa: E501
        """Get Supported Locales for Transcriptions  # noqa: E501

        Gets a list of supported locales for offline transcriptions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list_supported_locales(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TranscriptionsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.transcriptions_list_supported_locales_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def transcriptions_list_supported_locales_with_http_info(
        self, **kwargs
    ):  # noqa: E501
        """Get Supported Locales for Transcriptions  # noqa: E501

        Gets a list of supported locales for offline transcriptions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_list_supported_locales_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TranscriptionsLocalesGet200ApplicationJsonResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_list_supported_locales" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/locales",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="TranscriptionsLocalesGet200ApplicationJsonResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def transcriptions_update(self, id, **kwargs):  # noqa: E501
        """Update Transcription  # noqa: E501

        Updates the mutable details of the transcription identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param TranscriptionUpdate transcription_update: The updated values for the transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.transcriptions_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.transcriptions_update_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def transcriptions_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Transcription  # noqa: E501

        Updates the mutable details of the transcription identified by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcriptions_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the transcription. (required)
        :param TranscriptionUpdate transcription_update: The updated values for the transcription.
        :return: Transcription
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "transcription_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcriptions_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `transcriptions_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "transcription_update" in params:
            body_params = params["transcription_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/transcriptions/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="Transcription",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_create(self, **kwargs):  # noqa: E501
        """Create Web Hook  # noqa: E501

        If the property secret in the configuration is present and contains a non-empty string, it will be used to create a SHA256 hash of the payload with  the secret as HMAC key. This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                When calling back into the registered URL, the request will contain a X-MicrosoftSpeechServices-Event header containing one of the registered event  types. There will be one request per registered event type.                After successfully registering the web hook, it will not be usable until a challenge/response is completed. To do this, a request with the event type  challenge will be made with a query parameter called validationToken. Respond to the challenge with a 200 OK containing the value of the validationToken  query parameter as the response body. When the challenge/response is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebHook web_hook: The details of the new web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def web_hooks_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Web Hook  # noqa: E501

        If the property secret in the configuration is present and contains a non-empty string, it will be used to create a SHA256 hash of the payload with  the secret as HMAC key. This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                When calling back into the registered URL, the request will contain a X-MicrosoftSpeechServices-Event header containing one of the registered event  types. There will be one request per registered event type.                After successfully registering the web hook, it will not be usable until a challenge/response is completed. To do this, a request with the event type  challenge will be made with a query parameter called validationToken. Respond to the challenge with a 200 OK containing the value of the validationToken  query parameter as the response body. When the challenge/response is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebHook web_hook: The details of the new web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["web_hook"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_create" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "web_hook" in params:
            body_params = params["web_hook"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="WebHook",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_delete(self, id, **kwargs):  # noqa: E501
        """Delete Web Hook  # noqa: E501

        Deletes the web hook identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def web_hooks_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete Web Hook  # noqa: E501

        Deletes the web hook identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_delete" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `web_hooks_delete`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks/{id}",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_get(self, id, **kwargs):  # noqa: E501
        """Get Web Hook  # noqa: E501

        Gets the web hook identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def web_hooks_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Web Hook  # noqa: E501

        Gets the web hook identified by the given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `web_hooks_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="WebHook",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_list(self, **kwargs):  # noqa: E501
        """Get Web Hooks  # noqa: E501

        Gets the list of web hooks for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available hooks.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and webUrl.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'test'```</li></ul>
        :return: PaginatedWebHooks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def web_hooks_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get Web Hooks  # noqa: E501

        Gets the list of web hooks for the authenticated subscription.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int skip: Format - int32. Number of datasets that will be skipped.
        :param int top: Format - int32. Number of datasets that will be included after skipping.
        :param str filter: A filtering expression for selecting a subset of the available hooks.              <ul><li><b>Supported properties:</b> displayName, description, createdDateTime, lastActionDateTime, status and webUrl.</li><li><b>Operators:</b><ul><li>eq, ne are supported for all properties.</li><li>gt, ge, lt, le are supported for createdDateTime and lastActionDateTime.</li><li>and, or, not are supported.</li></ul></li><li><b>Example:</b>```filter=displayName eq 'test'```</li></ul>
        :return: PaginatedWebHooks
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["skip", "top", "filter"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_list" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "skip" in params:
            query_params.append(("skip", params["skip"]))  # noqa: E501
        if "top" in params:
            query_params.append(("top", params["top"]))  # noqa: E501
        if "filter" in params:
            query_params.append(("filter", params["filter"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="PaginatedWebHooks",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_ping(self, id, **kwargs):  # noqa: E501
        """Ping Web Hook  # noqa: E501

        The request body of the POST request sent to the registered web hook URL is of the same shape as in the GET request for a specific hook.  The Swagger Schema ID of the model is WebHookV3.                The request will contain a X-MicrosoftSpeechServices-Event header with the value ping. If the web hook was registered with  a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_ping(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_ping_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_ping_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def web_hooks_ping_with_http_info(self, id, **kwargs):  # noqa: E501
        """Ping Web Hook  # noqa: E501

        The request body of the POST request sent to the registered web hook URL is of the same shape as in the GET request for a specific hook.  The Swagger Schema ID of the model is WebHookV3.                The request will contain a X-MicrosoftSpeechServices-Event header with the value ping. If the web hook was registered with  a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_ping_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_ping" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `web_hooks_ping`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks/{id}:ping",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_test(self, id, **kwargs):  # noqa: E501
        """Test Web Hook  # noqa: E501

        The payload will be generated from the last entity that would have invoked the web hook. If no entity is present for none of the registered event types,  the POST will respond with 204. If a test request can be made, it will respond with 200.  The request will contain a X-MicrosoftSpeechServices-Event header with the respective registered event type.  If the web hook was registered with a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_test(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_test_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_test_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def web_hooks_test_with_http_info(self, id, **kwargs):  # noqa: E501
        """Test Web Hook  # noqa: E501

        The payload will be generated from the last entity that would have invoked the web hook. If no entity is present for none of the registered event types,  the POST will respond with 204. If a test request can be made, it will respond with 200.  The request will contain a X-MicrosoftSpeechServices-Event header with the respective registered event type.  If the web hook was registered with a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with  the secret as HMAC key. The hash is base64 encoded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_test_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_test" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `web_hooks_test`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks/{id}:test",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def web_hooks_update(self, id, **kwargs):  # noqa: E501
        """Update Web Hook  # noqa: E501

        If the property secret in the configuration is omitted or contains an empty string, future callbacks won't contain X-MicrosoftSpeechServices-Signature  headers. If the property contains a non-empty string, it will be used to create a SHA256 hash of the payload with the secret as HMAC key. This hash  will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                If the URL changes,  the web hook will stop receiving events until a  challenge/response is completed. To do this, a request with the event type challenge will be made with a query parameter called validationToken.  Respond to the challenge with a 200 OK containing the value of the validationToken query parameter as the response body. When the challenge/response  is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_update(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :param WebHookUpdate web_hook_update: The updated values for the web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.web_hooks_update_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.web_hooks_update_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def web_hooks_update_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update Web Hook  # noqa: E501

        If the property secret in the configuration is omitted or contains an empty string, future callbacks won't contain X-MicrosoftSpeechServices-Signature  headers. If the property contains a non-empty string, it will be used to create a SHA256 hash of the payload with the secret as HMAC key. This hash  will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.                If the URL changes,  the web hook will stop receiving events until a  challenge/response is completed. To do this, a request with the event type challenge will be made with a query parameter called validationToken.  Respond to the challenge with a 200 OK containing the value of the validationToken query parameter as the response body. When the challenge/response  is successfully completed, the web hook will begin receiving events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.web_hooks_update_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Format - uuid. The identifier of the web hook. (required)
        :param WebHookUpdate web_hook_update: The updated values for the web hook.
        :return: WebHook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "web_hook_update"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method web_hooks_update" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and (
            "id" not in params or params["id"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `id` when calling `web_hooks_update`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "web_hook_update" in params:
            body_params = params["web_hook_update"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # HTTP header `Content-Type`
        header_params[
            "Content-Type"
        ] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json", "application/merge-patch+json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["apiKeyHeader", "apiKeyQuery"]  # noqa: E501

        return self.api_client.call_api(
            "/webhooks/{id}",
            "PATCH",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="WebHook",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
